# Specialist Prompt: P2.1 — GitHub Agent

## Your Role
You are the **GitHub Agent Specialist**. Your job is to replace the mock GitHub tools with real implementations using the `gh` CLI (GitHub's official CLI tool).

## Context
The `GitHubAgent` in `src/agents/specialized.ts` has two mock tools: `list_pull_requests` and `get_pr_details`. Both return `[Mock]` strings. You need to replace these with real `gh` CLI calls.

## Why `gh` CLI over Octokit?
- `gh` is already installed on most developer machines
- No additional npm dependencies needed
- Handles auth automatically (uses `GITHUB_TOKEN` or browser OAuth)
- Simpler error handling

## What You Need to Do

### Step 1: Create a GitHub tool executor utility
```typescript
// src/tools/github.ts
import { execFile } from 'child_process';
import { promisify } from 'util';

const exec = promisify(execFile);

export async function ghCommand(args: string[]): Promise<{ stdout: string; stderr: string }> {
  try {
    return await exec('gh', args, {
      timeout: 30000,
      env: { ...process.env },
    });
  } catch (error) {
    const err = error as { stderr?: string; message: string };
    throw new Error(err.stderr || err.message);
  }
}

// Check if gh CLI is available and authenticated
export async function isGhAvailable(): Promise<boolean> {
  try {
    await exec('gh', ['auth', 'status']);
    return true;
  } catch {
    return false;
  }
}
```

### Step 2: Implement real tools
```typescript
// In src/agents/specialized.ts — GitHubAgent

protected registerTools(): void {
  this.registerTool({
    name: 'list_pull_requests',
    description: 'List pull requests in a repository',
    parameters: z.object({
      repo: z.string().describe('Repository in owner/repo format'),
      state: z.enum(['open', 'closed', 'all']).default('open'),
      limit: z.number().default(10),
    }),
    execute: async (params) => {
      const { repo, state, limit } = params as { repo: string; state: string; limit: number };
      const { stdout } = await ghCommand([
        'pr', 'list',
        '--repo', repo,
        '--state', state,
        '--limit', String(limit),
        '--json', 'number,title,author,state,createdAt,url',
      ]);
      return { toolCallId: generateId(), success: true, output: stdout };
    },
  });

  this.registerTool({
    name: 'get_pr_details',
    description: 'Get details of a specific pull request including diff stats',
    parameters: z.object({
      repo: z.string().describe('Repository in owner/repo format'),
      pr_number: z.number().describe('Pull request number'),
    }),
    execute: async (params) => {
      const { repo, pr_number } = params as { repo: string; pr_number: number };
      const { stdout } = await ghCommand([
        'pr', 'view', String(pr_number),
        '--repo', repo,
        '--json', 'number,title,body,author,state,additions,deletions,files,reviews,comments',
      ]);
      return { toolCallId: generateId(), success: true, output: stdout };
    },
  });

  this.registerTool({
    name: 'create_issue',
    description: 'Create a new GitHub issue',
    parameters: z.object({
      repo: z.string().describe('Repository in owner/repo format'),
      title: z.string().describe('Issue title'),
      body: z.string().describe('Issue body (markdown)'),
      labels: z.array(z.string()).optional().describe('Labels to apply'),
    }),
    execute: async (params) => {
      const { repo, title, body, labels } = params as {
        repo: string; title: string; body: string; labels?: string[];
      };
      const args = ['issue', 'create', '--repo', repo, '--title', title, '--body', body];
      if (labels?.length) args.push('--label', labels.join(','));
      const { stdout } = await ghCommand(args);
      return { toolCallId: generateId(), success: true, output: stdout };
    },
  });

  this.registerTool({
    name: 'review_pr',
    description: 'Get the diff and review comments for a PR',
    parameters: z.object({
      repo: z.string().describe('Repository in owner/repo format'),
      pr_number: z.number().describe('Pull request number'),
    }),
    execute: async (params) => {
      const { repo, pr_number } = params as { repo: string; pr_number: number };
      const { stdout } = await ghCommand([
        'pr', 'diff', String(pr_number),
        '--repo', repo,
      ]);
      return { toolCallId: generateId(), success: true, output: stdout };
    },
  });
}
```

### Step 3: Add auth check on initialization
```typescript
async initialize(): Promise<void> {
  await super.initialize();

  // Check gh CLI availability
  const available = await isGhAvailable();
  if (!available) {
    logger.warn('GitHub Agent: gh CLI not available or not authenticated. Run `gh auth login`.');
  }
}
```

## Security Considerations
- NEVER pass user input directly as shell arguments — always use the array form of `execFile` (not `exec` with string concatenation)
- Validate `repo` format matches `owner/repo` pattern before executing
- Set command timeouts to prevent hanging

```typescript
// Input validation example
function validateRepoFormat(repo: string): boolean {
  return /^[a-zA-Z0-9._-]+\/[a-zA-Z0-9._-]+$/.test(repo);
}
```

## Files to Modify
- `src/agents/specialized.ts` — Replace mock implementations

## Files to Create
- `src/tools/github.ts` — `gh` CLI wrapper utilities

## Acceptance Criteria
- [ ] `list_pull_requests` returns real PR data from GitHub
- [ ] `get_pr_details` returns real PR details with diff stats
- [ ] `create_issue` creates a real GitHub issue
- [ ] `review_pr` returns the actual PR diff
- [ ] Commands use array-form `execFile` (no shell injection)
- [ ] Repo format is validated before use
- [ ] Auth check runs on agent initialization
- [ ] Graceful error when `gh` is not installed

## Branch
Work in: `worktree/p2-github-agent`
