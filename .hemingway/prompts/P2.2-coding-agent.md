# Specialist Prompt: P2.2 — Coding Agent

## Your Role
You are the **Coding Agent Specialist**. Your job is to implement real file system and shell tools for the coding agent, with proper sandboxing to prevent access outside the project directory.

## Context
The `CodingAgent` in `src/agents/specialized.ts` has mock `read_file` and `write_file` tools. You need real implementations with path sandboxing.

## What You Need to Do

### Step 1: Create a sandboxed file system utility
```typescript
// src/tools/filesystem.ts
import fs from 'fs/promises';
import path from 'path';

export class SandboxedFS {
  private projectRoot: string;

  constructor(projectRoot: string) {
    this.projectRoot = path.resolve(projectRoot);
  }

  // Resolve a path and verify it's within the project root
  private resolveSafe(filePath: string): string {
    const resolved = path.resolve(this.projectRoot, filePath);
    if (!resolved.startsWith(this.projectRoot + path.sep) && resolved !== this.projectRoot) {
      throw new Error(`Access denied: ${filePath} is outside the project directory`);
    }
    return resolved;
  }

  async readFile(filePath: string): Promise<string> {
    const safe = this.resolveSafe(filePath);
    return fs.readFile(safe, 'utf-8');
  }

  async writeFile(filePath: string, content: string): Promise<void> {
    const safe = this.resolveSafe(filePath);
    await fs.mkdir(path.dirname(safe), { recursive: true });
    await fs.writeFile(safe, content, 'utf-8');
  }

  async listDir(dirPath: string): Promise<string[]> {
    const safe = this.resolveSafe(dirPath);
    const entries = await fs.readdir(safe, { withFileTypes: true });
    return entries.map(e => e.isDirectory() ? `${e.name}/` : e.name);
  }

  async searchContent(pattern: string, glob?: string): Promise<string> {
    // Use ripgrep if available, fall back to basic search
    const { execFile } = await import('child_process');
    const { promisify } = await import('util');
    const exec = promisify(execFile);

    try {
      const args = ['--no-heading', '--line-number', '--color', 'never', pattern, this.projectRoot];
      if (glob) args.push('--glob', glob);
      const { stdout } = await exec('rg', args, { timeout: 10000 });
      return stdout;
    } catch {
      // Fallback: basic grep
      const { stdout } = await exec('grep', ['-rn', pattern, this.projectRoot], { timeout: 10000 });
      return stdout;
    }
  }
}
```

### Step 2: Implement the tools
```typescript
// In CodingAgent.registerTools()

const sandbox = new SandboxedFS(process.cwd());

this.registerTool({
  name: 'read_file',
  description: 'Read the contents of a file',
  parameters: z.object({
    path: z.string().describe('File path relative to project root'),
  }),
  execute: async (params) => {
    const { path: filePath } = params as { path: string };
    const content = await sandbox.readFile(filePath);
    return { toolCallId: generateId(), success: true, output: content };
  },
});

this.registerTool({
  name: 'write_file',
  description: 'Write content to a file (creates directories if needed)',
  parameters: z.object({
    path: z.string().describe('File path relative to project root'),
    content: z.string().describe('Content to write'),
  }),
  execute: async (params) => {
    const { path: filePath, content } = params as { path: string; content: string };
    await sandbox.writeFile(filePath, content);
    return { toolCallId: generateId(), success: true, output: `Wrote ${content.length} bytes to ${filePath}` };
  },
});

this.registerTool({
  name: 'search_code',
  description: 'Search for a pattern in the codebase',
  parameters: z.object({
    pattern: z.string().describe('Search pattern (regex supported)'),
    glob: z.string().optional().describe('File glob filter, e.g. "*.ts"'),
  }),
  execute: async (params) => {
    const { pattern, glob } = params as { pattern: string; glob?: string };
    const results = await sandbox.searchContent(pattern, glob);
    return { toolCallId: generateId(), success: true, output: results || 'No matches found.' };
  },
});

this.registerTool({
  name: 'run_shell',
  description: 'Execute a shell command in the project directory',
  parameters: z.object({
    command: z.string().describe('Shell command to execute'),
  }),
  execute: async (params) => {
    const { command } = params as { command: string };
    // SECURITY: Run in project directory, with timeout
    const { execFile } = await import('child_process');
    const { promisify } = await import('util');
    const exec = promisify(execFile);
    const { stdout, stderr } = await exec('sh', ['-c', command], {
      cwd: process.cwd(),
      timeout: 30000,
      env: { ...process.env, NODE_ENV: 'development' },
    });
    return {
      toolCallId: generateId(),
      success: true,
      output: stdout + (stderr ? `\nSTDERR: ${stderr}` : ''),
    };
  },
});
```

## Security Considerations
- ALL file paths must be resolved and checked against the project root
- Shell commands should have timeouts
- Write operations should be logged for audit
- Never allow execution of commands that modify files outside the sandbox

## Files to Create
- `src/tools/filesystem.ts` — Sandboxed file system utilities

## Files to Modify
- `src/agents/specialized.ts` — Replace mock tools with real implementations

## Acceptance Criteria
- [ ] `read_file` reads real files within the project directory
- [ ] `read_file` rejects paths outside the project (../../etc/passwd)
- [ ] `write_file` creates files and intermediate directories
- [ ] `search_code` returns real search results
- [ ] `run_shell` executes commands with timeout
- [ ] All operations are sandboxed to the project directory

## Branch
Work in: `worktree/p2-coding-agent`
